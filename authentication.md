### Thinking out loud regarding authentication

Something I've been thinking about regarding tripcodes.

Because the tripcodes are generated by applying a specific
algorithm to a secret, it's essentially impossible to assert
that one's tripcode will be the same across all servers â€”
should some server use another algorithm (or, more likely,
act malevolently) an identity could essentially be hijacked
on that server.

For instance someone could make a server and create a 
*custom* tripcode that is the same as someone's tripcode
on e.g. http://server.example.com. Someone could make a
custom tripcode on that server that exactly matches yours.
How would people know it's not actually you then?

Perhaps this is just an inherent problem to this design
that can't really be elegantly solved; just like among
the imageboards, the "moot" on whateverchan can't be
assumed to be "moot" on 4chan.

https://en.wikipedia.org/wiki/Digital_signature

Thinking about whether a public key infrastructure can
somehow be used to verify author identity without trusting
the server.

So...

The "private key" in would be your secret, known to your
client but not to any server.

Each message (or each request?) that you send is signed
automatically by the client using your secret as such:

```Packet = SenderID + Message + Message.Encrypt(Secret))```

The server receives the packet and redistributes it to the
connected clients that should receive it.

> *Question: What is the SenderID here?*
>
> *Possibility: `SHA256(Secret)`, stored in advance in the repository (see below).*

Once the Packet reaches a client, the client has to verify
its authenticity. This can be done by decrypting the signature
(i.e. `Message.Encrypt(Secret))`) using the public key referred
to via "SenderID" and comparing it with the original message.

> *Question: How often does this check need to be performed?*

The public key can be accessed via a trusted repository,
for instance auth.example.com/keys. For efficiency, the client
can periodically download and cache this repository so it doesn't
need to perform a HTTP request on each received message.

**So now the question becomes: what are the problems with this approach?**
